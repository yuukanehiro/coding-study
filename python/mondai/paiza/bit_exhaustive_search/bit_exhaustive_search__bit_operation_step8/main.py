


def get_answer(a: list[int]) -> int:
    ans = 0
    for v in a:
        ans ^= v

    return ans

def main():
    n = int(input())
    a = list(map(int, input().split()))
    print(get_answer(a))
    

def test():
    in_a1 = [
        1,
        3,
        3,
        5,
        1,
    ]
    expect1 = 5
    assert get_answer(in_a1) == expect1

    in_a2 = [
        1002,
        2,
        923,
        923,
        923,
        923,
        2,
        2,
        923,
        923,
        2,
        923,
        2,
        2,
        923,
        7,
        7,
    ]
    expect2 = 1002
    assert get_answer(in_a2) == expect2

test()
main()

# コードの解説
# ans = 0 で開始します。
# ans ^= x とすることで、これまでの計算結果と新しい数 x を XOR 演算します。

# 例えば、入力が 1 3 3 5 1 の場合：
# 0 ^ 1 → 1
# 1 ^ 3 → 2 (二進数: 01 ^ 11 = 10)
# 2 ^ 3 → 1 (二進数: 10 ^ 11 = 01) ※ここで 3 が相殺された！
# 1 ^ 5 → 4 (二進数: 001 ^ 101 = 100)
# 4 ^ 1 → 5 (二進数: 100 ^ 001 = 101) ※ここで 1 が相殺された！
# 結果、奇数回（1回）登場した 5 だけが残ります。

# Q
# 排他的論理和 (XOR) 応用 Python3編（paizaランク D 相当）
# 問題にチャレンジして、ユーザー同士で解答を教え合ったり、コードを公開してみよう！

# シェア用URL:
# https://paiza.jp/works/mondai/bit_exhaustive_search/bit_exhaustive_search__bit_operation_step8
# 問題文のURLをコピーする
#  下記の問題をプログラミングしてみよう！
# 前回の問題で学習した排他的論理和 (XOR) をさらに使いこなせるようにしましょう。
# 同じ数同士の排他的論理和は 0 になるという性質があります。
# また、0 と任意の数 x の排他的論理和は x になります。
# これら性質を利用して、数列 A に奇数回出現する整数 1 つを出力してください。
# ただし、数列 A に奇数回出現する整数は 1 つしかないことが保証されます。

# ▼　下記解答欄にコードを記入してみよう

# 入力される値
# N
# A_1 A_2 ... A_N

# ・ 1 行目には、数列の長さを表す整数 N が与えられます。
# ・ 2 行目には、数列の i 番目の要素を表す整数 A_i が空白区切りで与えられます。
# ・ 入力は合計で 2 行からなり、入力値最終行の末尾に改行が 1 つ入ります。


# 入力値最終行の末尾に改行が１つ入ります。
# 文字列は標準入力から渡されます。 標準入力からの値取得方法はこちらをご確認ください
# 期待する出力
# 数列 A に奇数回出現する整数 1 つを出力してください。

# 条件
# すべてのテストケースにおいて、以下の条件をみたします。

# ・ 1 ≦ N ≦ 100
# ・ N は奇数
# ・ 0 ≦ A_i < 2^10
# ・ 数列 A に奇数回出現する整数は 1 つ

# 入力例1
# 5
# 1 3 3 5 1

# 出力例1
# 5

# 入力例2
# 17
# 1002 2 923 923 923 923 2 2 923 923 2 923 2 2 923 7 7

# 出力例2
# 1002