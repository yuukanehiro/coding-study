


def get_answer(qs: list[list[int]], b: str) -> list[str]:
    ans: list[str] = []

    for i, a in enumerate(qs):
        # refs
        # > 1 k：B を右に k ビットシフトしたものを出力する。
        # > 2 k：B を左に k ビットシフトしたものを出力する。

        # 左右の動作の違い演算桁数（ビット数）の変化対策
        # 右シフト (>>)減る（または変わらない）文字列が短くなるので zfill で左を埋めるだけでOK。
        # 左シフト (<<)増える文字列が長くなりすぎるので、s[-width:] で右側から切り取る必要がある。
        width = 10
        if a[0] == 1:
            r = int(b, 2) >> a[1]
            r = bin(r)
            ans.append(str(r[2:].zfill(width)))
        elif a[0] == 2:
            r = int(b, 2) << a[1]
            r = bin(r)
            r = str(r[2:].zfill(width))
            # 重要
            ans.append(r[-width:])
        else:
            exit("panic")

    return ans


def main():
    b = input()
    n = int(input())
    qs = []
    for i in range(n):
        qs.append(list(map(int, input().split())))

    ans = get_answer(qs, b)
    for a in ans:
        print(a)

def test():
    b1 = "0011010101"
    q1 = [
        [1, 1],
        [2, 1],
        [1, 3],
        [2, 10],
        [1, 9],
    ]
    expect1 = [
        "0001101010",
        "0110101010",
        "0000011010",
        "0000000000",
        "0000000000",
    ]
    assert get_answer(q1, b1) == expect1

    b2 = "0011100100"
    q2 = [
        [1, 5],
        [1, 4],
        [1, 2],
        [1, 10],
        [2, 1],
        [1, 2],
        [1, 4],
        [1, 9],
        [1, 9],
        [2, 4],
    ]
    expect2 = [
        "0000000111",
        "0000001110",
        "0000111001",
        "0000000000",
        "0111001000",
        "0000111001",
        "0000001110",
        "0000000000",
        "0000000000",
        "1001000000",
    ]
    assert get_answer(q2, b2) == expect2

test()
main()

#Q
# ビットシフト 基礎 1 Python3編（paizaランク C 相当）
# 問題にチャレンジして、ユーザー同士で解答を教え合ったり、コードを公開してみよう！

# シェア用URL:
# https://paiza.jp/works/mondai/bit_exhaustive_search/bit_exhaustive_search__bit_operation_step9
# 問題文のURLをコピーする
#  下記の問題をプログラミングしてみよう！
# ビット列を右もしくは左にずらすことをビットシフトと呼びます。
# 特に、ビット列を左にずらすことを論理左シフト演算または単に左シフト、右にずらすことを論理右シフト演算または単に右シフトと呼びます。
# シフトによってはみ出た部分のビットは捨てられ、足りない部分のビットは 0 で埋められます。

# 例えば、4 桁のビット列 0011 を 1 ビット右シフトすると 0001 になります。
# 4 桁のビット列 1010 を 2 ビット左シフトすると 1000 になります。

# 10 桁のビット列 B が与えられます。
# Q 個のクエリが与えられるので順に解答してください。
# クエリは以下の 2 種類のいずれかです。

# ・ 1 k：B を右に k ビットシフトしたものを出力する。
# ・ 2 k：B を左に k ビットシフトしたものを出力する。

# ▼　下記解答欄にコードを記入してみよう

# 入力される値
# B
# Q
# query_1
# query_2
# ...
# query_Q

# ・ 1 行目に、ビット列 B が与えられます。
# ・ 2 行目に、クエリの個数を表す整数 Q が与えられます。
# ・ 続く Q 行の i (1 ≦ i ≦ Q) 行目には、i 個目のクエリが与えられます。クエリは問題文の形式で与えられます。
# ・ 入力は合計で Q+2 行からなり、入力値最終行の末尾に改行が 1 つ入ります。


# 入力値最終行の末尾に改行が１つ入ります。
# 文字列は標準入力から渡されます。 標準入力からの値取得方法はこちらをご確認ください
# 期待する出力
# 期待する出力は Q 行からなります。
# i (1 ≦ i ≦ Q) 行目には、i 個目のクエリに対する答えを出力してください。

# 条件
# すべてのテストケースにおいて、以下の条件をみたします。

# ・ 1 ≦ Q ≦ 10
# ・ |B| = 10
# ・ B は 0 と 1 からなる
# ・ すべてのクエリについて 1 ≦ k ≦ 10

# 入力例1
# 0011010101
# 5
# 1 1
# 2 1
# 1 3
# 2 10
# 1 9

# 出力例1
# 0001101010
# 0110101010
# 0000011010
# 0000000000
# 0000000000

# 入力例2
# 0011100100
# 10
# 1 5
# 1 4
# 1 2
# 1 10
# 2 1
# 1 2
# 1 4
# 1 9
# 1 9
# 2 4

# 出力例2
# 0000000111
# 0000001110
# 0000111001
# 0000000000
# 0111001000
# 0000111001
# 0000001110
# 0000000000
# 0000000000
# 1001000000