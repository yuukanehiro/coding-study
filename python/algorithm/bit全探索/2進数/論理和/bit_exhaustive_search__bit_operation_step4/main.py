


def get_answer(a: str, b: str, digit: int) -> list[str]:
    ans: list[str] = []
    for i in range(digit):
        ans.append(str(int(a[i]) | int(b[i])))

    return ans

def main():
    a = input()
    b = input()
    digit = 10

    ans = get_answer(a, b, digit)
    print("".join(ans))

def test():
    digit = 10
    in_a1 = "0011001011"
    in_b1 = "1010011010"
    expect1 = [
        "1",
        "0",
        "1",
        "1",
        "0",
        "1",
        "1",
        "0",
        "1",
        "1",
    ]
    assert(get_answer(in_a1, in_b1, digit)) == expect1

    in_a2 = "0001100111"
    in_b2 = "0000011111"
    expect2 = [
        "0",
        "0",
        "0",
        "1",
        "1",
        "1",
        "1",
        "1",
        "1",
        "1",
    ]
    assert(get_answer(in_a2, in_b2, digit)) == expect2

test()
main()

# Q
# 論理和 (OR) 基礎 1 Python3編（paizaランク D 相当）
# 問題にチャレンジして、ユーザー同士で解答を教え合ったり、コードを公開してみよう！

# シェア用URL:
# https://paiza.jp/works/mondai/bit_exhaustive_search/bit_exhaustive_search__bit_operation_step4
# 問題文のURLをコピーする
#  下記の問題をプログラミングしてみよう！
# 与えられた二つのビット列の論理和 (OR) をとるプログラムを作成してみましょう。
# 論理和では、少なくとも片方のビットが 1 の場合のみ 1 となります。
# 例えば、ビット列 0011 と 0101 の論理和は 0111 です。

# 10 桁のビット列 B_1, B_2 が与えられるので、B_1 と B_2 のビット毎の論理和 (OR) を 10 桁のビット列で出力してください。

# ▼　下記解答欄にコードを記入してみよう

# 入力される値
# B_1
# B_2

# ・ 1 行目にビット列 B_1が与えられます。
# ・ 2 行目にビット列 B_2 が与えられます。
# ・ 入力は合計で 2 行からなり、入力値最終行の末尾に改行が 1 つ入ります。


# 入力値最終行の末尾に改行が１つ入ります。
# 文字列は標準入力から渡されます。 標準入力からの値取得方法はこちらをご確認ください
# 期待する出力
# B_1 と B_2 のビット毎の論理和 (OR) をとった結果を 10 桁のビット列で出力してください。

# 条件
# すべてのテストケースにおいて、以下の条件をみたします。

# ・ B_1, B_2 は 0 または 1 からなる
# ・ |B_1|, |B_2| = 10

# 入力例1
# 0011001011
# 1010011010

# 出力例1
# 1011011011

# 入力例2
# 0001100111
# 0000011111

# 出力例2
# 0001111111